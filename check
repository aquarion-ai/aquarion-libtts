#!/usr/bin/env nu

# Check code for quality and correctness
#
# Running `check` without a sub-command is the same as running `check commit`.
def main []: nothing -> string {
    main commit
}

# Run all code checks that should pass before committing.
#
# This performs the following checks in order and stops on the first failure:
#
#   - Static type checking
#   - Formatting
#   - Linting
#   - Unit testing
def "main commit" []: nothing -> string {
    common
    hatch test --parallel
}

# Run all code checks that should pass before pushing.
#
# This performs the following checks in order and stops on the first failure:
#
#   - All the checks from `check commit`
#   - Coverage
def "main push" []: nothing -> string {
    common
    hatch test --cover
    hatch run accept:check
}

# Run acceptance tests.
def --wrapped "main accept" [
    ...rest: string # Extra arguments for radish
]: nothing -> string {
    hatch run accept:check ...$rest
}

# Run coverage on acceptance tests.
def --wrapped "main accept cover" [
    ...rest: string # Extra arguments for radish
]: nothing -> string {
    hatch run accept:cover ...$rest
}

## Command run by Hatch scripts. DO NOT RUN DIRECTLY.

# Internal command. Do not use.
def --wrapped "main zzz_hatch accept" [...rest: string]: nothing -> string {
    radish -b steps/ -t --shuffle features/ ...$rest
}

# Internal command. Do not use.
def --wrapped "main zzz_hatch accept cover" [...rest:string]: nothing -> string  {
    (
        coverage run --rcfile=radish_coverage.toml
        ...(which radish).path -b steps/ -t --shuffle features/ ...$rest
    )
    coverage report -m --rcfile=radish_coverage.toml
}



## Internal commands

# Common checks for all sub-commands.
def common []: nothing -> string {
    hatch run types:check
    hatch fmt
}
